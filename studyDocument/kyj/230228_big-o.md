# 코딩호러: Big-O part1

책 코딩호러의 개발자의 소양 부분을 읽다가 모르겠는 부분이 있어 검색해보니
흥미로운 부분이 있어 남깁니다.

## 1. Big O 표기법
답이 도출되는 시간을 자원으로 볼 때, 일반적으로 알고리즘을 완료하는 데 걸리는 시간이 짧을수록 좋기 때문에.
알고리즘이 사용하는 디스크 공간 또는 시간과 같은 리소스의 수에 관한 효율성을 표기해주는 수식화 한 것입니다.

알고리즘의 효율성을 표기해주는 표기법. 혹자는 `알고리즘 스카우터`라고도 부릅니다.

효율성 표기법은 본 커밋에서 서술하는 `빅오(Big-O)` 이외에도
빅오메가(big-Ω),빅세타(big-Θ)등의 표기법이 있습니다.

## 2. 일정 시간 알고리즘 – O (1)
입력 크기 == 소요되는 시간.

```
ex_1
int n = 1000;
System.out.println("Hey - your input is: " + n);

==========================
ex_2
int n = 1000;
System.out.println("Hey - your input is: " + n);
System.out.println("Hmm.. I'm doing more stuff with: " + n);
System.out.println("And more: " + n);
```
위 코드들은 N이 무엇이던 실행하는 데 일정한 시간이 걸립니다.
n의 크기에 의존하지 않기 때문입니다.

2번 예도 println이 3번 호출되기에 모두 처리되는데
1번 예 보다는 3배정도 걸리겠지만
단지 일정한 시간이 걸린다는 것에 주목해야 합니다.

## 3. 로그 시간 알고리즘 – O (log n)
일정 시간 알고리즘을 제외하면 로그 시간 알고리즘이 그 다음으로 빠릅니다.
일반적인 예는 `이진 검색 알고리즘`이 있습니다.
여기서 중요한 것은 입력의 로그에 비례 하여 실행 시간이 증가 한다는 것입니다.

```
ex_1
for (int i = 1; i < 8; i = i * 2){
    System.out.println("Hey - I'm busy looking at: " + i);
}

## print
Hey - I'm busy looking at: 1
Hey - I'm busy looking at: 2
Hey - I'm busy looking at: 4
```

## 4. 선형 시간 알고리즘 – O (n)
어떤 것이 선형 적으로 성장한다고 말하면 입력 크기에 정비례하여 성장한다는 의미입니다.
대표적 예로는 `for case`이 있습니다.

```
ex_1
for (int i = 0; i < n; i++) {
    System.out.println("Hey - I'm busy looking at: " + i);
}
```
for 루프는 n번 돌아가기 때문에 이 작업이 모두 실행되는 데 얼마나 오래 걸릴지 정확히 알 수 없으며,
세부 사항에 대해서는 신경 쓰지 않습니다. 

단순히 제시된 간단한 알고리즘이 입력 크기에 따라 선형 적으로 증가한다면
선형 시간 알고리즘이라고 볼 수 있습니다.

```
ex_2
for (int i = 0; i < n; i++) {
    System.out.println("Hey - I'm busy looking at: " + i);
    System.out.println("Hmm.. Let's have another look at: " + i);
    System.out.println("And another: " + i);
}
```
