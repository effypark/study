# 비동기 axios통신

```
//강의 연장, 만료 적용
const courseEndDateChange = (
    user_course_id,            //
    date_time,                 //
    changeType,                //
    selected_course_list,      //
) => {
    if (changeType === 'expired') {
        date_time = moment(new Date()).format("YYYY-MM-DD HH:mm:ss");
    }
    let response = null;

    //선택한 리스트 목록 forEach
    selected_course_list.forEach(element =>
        response = CourseModel.patchCourseEndDateChange( // API호출
            element.id,
            date_time,
        )
    );
    
    //넘어온 promise 값 확인
    response.then((data) => {
        //결과 상태 값에 따른 text 표기 변경
        let text = data.message === 'success'
            ? "강의가 " + courseActionName + "되었습니다."
            : "강의 " + courseActionName + "에 실패하었습니다.";

        SweetAlert.fire({
            title: text,
        }).then((result) => {
            if (data.message === 'success') {
                if(result.value){ // 확인(닫기) 클릭시 초기화 && 목록 갱신
                    setLoading(true); 
                    AccountModel.getAccountCourse(props.addional_props).then(({course}) => {
                        setCourseSet(course);
                        setLoading(false);
                    });
                }
            } else { // 실패시 버튼 클릭 전으로 초기화.
                setCourseAction('');
                SetTargetAccountId('');
            }
        }).catch(error => {
            console.log(error);
        });
    });
};
```

```
async patchCourseEndDateChange(user_course_id, date_time) {
    //통신하여 가져온 object 결과값을 구조분해 할당해줍니다.
    const {data} = await axios.patch(process.env.REACT_APP_API_URL + `/cms-api/v1/course/course-transfer/${user_course_id}/${date_time}`, {
        user_course_id: user_course_id,
        date_time: date_time,
    });
    return data; //결과값을 리턴해줍니다.
}
```
model로 분리하고 import해서 쓰는 과정에서 비동기 형태로 인해 retrun값이 전달되지 않는 삽질이나,
await로 인한 foreach로 감싸는 부분이 적용되지 못해 model 부분이 아닌 요청하는 페이지에서
동작하도록 수정해야 했습니다.

굉장히 단순하고 빠르게 끝날 것 같았던 해당작업은
역시 코드는 사용하지 않으면 기억에서 흐릿하고 사라진다는 것을 깊게 깨달았습니다.
