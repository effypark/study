# Clean Architecture

## 컴포넌트 원칙

### 컴포넌트: 배포단위

개발 초창기에는 프로그램을 로드할 메모리의 위치를 선정하는 일이 우선시되었고,  
한번 위치가 결정되면 재배치가 불가능했다. 따라서 라이브러리 함수의   
코드를 어플리케이션 코드에 직접 포함시켜서 컴파일 함.  
그러나 이 방식으로는 함수 라이브러리가 커질수록 컴파일이  
너무 오래걸린다는 단점이 있음.

따라서 함수라이브러리 코드와 어플리케이션 코드를 분리하고 개별적으로  
컴파일 한 후, 메모리의 특정 위치에 로드함.   
어플리케이션을 실행해야한다면 함수 라이브러리를 먼저 로드해야 하는데,  
이는 어플리케이션이 특정 주소 공간에서만 잘 동작한다는 단점이 있었음.  
따라서 어플리케이션이나 함수 라이브러리가 커질수록 어플리케이션을  
특정 주소공간에 위치시키기 위해 어플리케이션을 계속 세그먼트로  
분리해야하는 단편화 현상이 발생함.

이 문제를 해결하기 위해 ‘재배치성’과 ‘링크’개념을 사용함.  
로더를 이용해 코드 자체를 포함시키는 것이 아니라  
메모리에 재배치할 수 있는 바이너리를 생성하도록   
컴파일러를 수정하도록 하는 것.   
또한 컴파일러가 재배치 가능한 라이브러리를   
메타데이터 형태로 생성하도록 수정하여  
외부링크가 가능하게 됨.  
따라서 더이상 어플리케이션을 세분화 하는 일 없이,  
필요한 함수만 로드할 수 있게 됨. 이를 통해 프로그램을  
개별적으로 컴파일하고 로드할 수 있는 단위가 생겨나게 됨.

이렇게 런타임에 플러그인 형태로 결합할 수 있는 동적  
링크파일이 컴포넌트.   
이는 배포 단위로도 정의 할 수 있으며, 시스템의  
구성 요소로 배포할 수 있는 가장 작은 단위라고도 할 수 있음.  
잘 설계된 컴포넌트는 반드시 독립적으로 배포가능하고,  
독립적으로 개발 가능한 능력을 갖춰야 함.

### 컴포넌트 응집도의 세가지 원칙

- REP(Reuse/Release Equivalence Principle): 재사용/릴리즈 등가 원칙
: 재사용 단위는 릴리즈 단위와 같다.

이 원칙을 조금 더 풀어서 설명하자면, 하나의 컴포넌트로  
묶인 클래스와 모듈은 버전 번호가 같아야 하며,  
동일한 릴리스로 추적 관리되고, 동일한 릴리스 문서에 포함되어야  
한다는 뜻. 이 원칙은 클래스와 모듈을 단일 컴포넌트로 묶는 방법에  
대한 구체적인 원칙이 아니고 그냥 ‘이치에 맞는'듯한 이야기이지만  
이 원칙을 어기면 ‘이치에 맞지 않는' 컴포넌트가 되어버리므로  
중요한 원칙.

CCP(Common Closure Principle): 공통 폐쇄 원칙

: 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라.

어플리케이션의 ‘유지보수성'을 고려한 원칙.   
변경될 가능성이 있는 클래스를 모두 한 곳으로 묶어  
릴리스/재검증/배포하는 일과 관련된 작업량을 최소화하기 위함.

이는 서로 다른 이유로 변경되면 서로 다른 클래스로 분리하라는  
관점에서 컴포넌트 관점의 SRP(단일 책임 원칙)라고도 할 수 있고,  
변경에는 닫혀있고 확장에는 열려있다는 관점에서 OCP(개방폐쇄원칙)과도  
밀접한 관련이 있음.

CRP(Common Reuse Principle): 공통 재사용 원칙

: 컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.

이 원칙은 어떤 클래스를 한데 묶어도 되는지보다,  
어떤 클래스를 한 데 묶어서는 안 되는지에 대해 이야기를 하는 원칙.   
의존하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해  
의존함을 확실히 인지해야 함.  
사용하는 컴포넌트가 의존하지 않는 클래스를 포함한 컴포넌트의  
변경에 영향을 받지 않도록 하기 위함.

REP와 CRP에만 중점을 두면, 사소한 변경이 생겼을 때 너무 많은  
컴포넌트에 영향을 미치고, REP와 CCP에만 과도하게 집중하면  
불필요한 릴리즈가 너무 빈번해지므로, 각 개발단계에 맞게 균형을  
잘 이뤄 설계하는 것이 중요.

