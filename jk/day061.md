7. Dictionary(딕셔너리 자료형)  

Dictionary는 키=값 형태로 이루어진 자료형입니다.   
이렇게 대응 관계를 나타내는 자료형을 연관 배열 혹은   
Hash라고 합니다. 대표적인 예로는 루비의 Hash와 C#의 Dictionary가 있습니다.

이제 Dictionary라는 것은 어떻게 생겼는지 알아보도록 하겠습니다.
```
dic1 = dict()
dic2 = {'k1': 'v1', 'k2': 'v2', 'k3': 'v3'}
dic3 = dict([('name', 'L3opold7'), ('phone', '010-1234-5678')])
dic4 = dict(firstname='Myungseo', lastname='Kang')
dic5 = {'ls': ['a', 'b', 'c']}

print(dic2)               # {'k1': 'v1', 'k3': 'v3', 'k2': 'v2'}
print(dic2['k2'])         # v2
print(dic3)               # {'phone': '010-1234-5678', 'name': 'L3opold7'}
print(dic3['name'])       # L3opold7
print(dic4)               # {'firstname': 'Myungseo', 'lastname': 'Kang'}
print(dic4['firstname'])  # Myungseo
print(dic5['ls'])         # ['a', 'b', 'c']
```
빈 Dictionary를 만들땐 dict() 함수를 사용하면 됩니다.   
물론 내용이 있는 Dictionary를 만들 때 사용해도 됩니다!   
그리고 value 값을 호출할 때는 Dictionary이름[‘키값’] 으로  
호출하게 되면 값을 얻을 수 있습니다.   
또한 Dictionary의 값으로 List도 넣을 수 있다.
```
test = {1: 'first'}
test[2] = 'second'

print(test)  # {2: 'second', 1: 'first'}
Dictionary는 간단하게 키값을 지정해주고 추가해주면 됩니다.

test = {1: 'first', 2: 'second', 3: 'third'}

del test[2]
print(test)  # {1: 'first', 3: 'third'}
```
삭제는 List에서 사용했듯이 del() 함수를 사용하면 됩니다.
```
test = {'name': 'Myungseo', 'nickname': 'L3opold7', 'birthday': '0523'}
print(test.keys())    # dict_keys(['name', 'nickname', 'birthday'])
print(test.values())  # dict_values(['Myungseo', 'L3opold7', '0523'])
print(test.items())   # dict_items([('nickname', 'L3opold7'), ('name', 'Myungseo'), ('birthday', '0523')])
keys(), values() 함수를 통해서 딕셔너리의 key 혹은 value를 dict_keys 혹은 dict_values 객체로 얻을 수 있습니다. items() 함수는 key와 value를 Tuple을 사용해서 묶은 값을 dict_items 라는 객체로 반환해줍니다.

test = {'name': 'Myungseo', 'nickname': 'L3opold7', 'birthday': '0523'}
test.clear()
print(test)  # {}
```
clear() 함수를 이용해서 모두 지워버릴 수 있다!
```
test = {'name': 'Myungseo', 'nickname': 'L3opold7', 'birthday': '0523'}

print(test.get('no_key'))  # None
print(test.get('name'))    # Myungseo
print(test['name'])        # Myungseo
print(test['no_key'])      # Error
```
test[‘no_key’] 의 경우에는 Error를 내뱉지만  
test.get(‘no_key’)는 None 객체를 반환하기 때문에  
get(x, y) 함수를 쓰는 것이 더 적절해보입니다.  
get(x, y) 함수는 Dictionary 안에 x 라는  
키 값이 없을 경우 y 라는 디폴트 값을 반환해줍니다.
```
test = {'name': 'Myungseo', 'nickname': 'L3opold7', 'birthday': '0523'}

print('name' in test)    # True
print('no_key' in test)  # False
```
8. Set(집합 자료형)  

집합 자료형인 Set 입니다. 말 그대로 집합을 나타내기 위한  
자료형입니다. 특징으로는 중복을 허용하지 않고, 순서가 없다는 것이 있습니다.
```
s = set([1, 2, 3, 4, 5])
print(s)  # {1, 2, 3, 4, 5}

hello = set('Hello World!')
print(hello)  # {' ', 'H', '!', 'e', 'l', 'o', 'd', 'W', 'r'}
```
위와 같이 선언할 수 있습니다.   
위에서 말한 두 가지 특징이 잘 드러나는 것을 볼 수 있습니다.

List와 Tuple은 순서가 있기 때문에 인덱싱을 통해 원하는  
값을 가져올 수 있었지만, Set은 Dictionary와 비슷하게 순서가 없는  
자료형이기 때문에 인덱싱이 불가능합니다.   
만약 Set에서 인덱싱을 하고 싶다면 List나 Tuple로 형 변환을 시킨 뒤에 해야합니다.

아무래도 Set은 집합 자료형이다보니 교집합, 차집합, 합집합 등  
집합 연산에 있어 매우 유리합니다.
```
set1 = set([1, 2, 3, 4, 5, 6])
set2 = set([5, 6, 7, 8, 9, 0])

print(set1 & set2)  # {5, 6}
print(set1 | set2)  # {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
print(set1 - set2)  # {1, 2, 3, 4}
print(set2 - set1)  # {0, 8, 9, 7}
```
차례대로 교집합, 합집합, set1-set2 차집합,  
set2-set1 차집합 입니다. 위의 코드는 아래와 같이 나타낼수도 있습니다.
```
set1 = set([1, 2, 3, 4, 5, 6])
set2 = set([5, 6, 7, 8, 9, 0])

print(set1.intersection(set2))  # {5, 6}
print(set1.union(set2))         # {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
print(set1.difference(set2))    # {1, 2, 3, 4}
print(set2.difference(set1))    # {0, 8, 9, 7}
```
이렇게 Set 자료형의 내장 함수를 통해서 교집합, 차집합, 합집합을 구할 수 있습니다.
```
set1 = set([1, 2, 3, 4])
set1.add(4)
print(set1)  # {1, 2, 3, 4}

set1.add(5)
print(set1)  # {1, 2, 3, 4, 5}
```
add(x) 함수를 통해서 값을 추가할 수 있습니다. Set 자료형의  
특징답게 기존에 있던 값을 추가할 경우에는 추가되지 않습니다.
```
set1 = set(1, 2)
set1.update([3, 4, 5])

print(set1)  # {1, 2, 3, 4, 5}
```
update(x) 함수를 통해서 여러 개의 값을 추가할 수 있습니다.   
x의 위치에는 iterable, 즉 반복 가능한 자료형이 와야합니다.    
List나 Tuple이 대표적인 예입니다.
```
set1 = set([1, 2, 3, 4, 5])
set1.remove(3)

print(set1)  # {1, 2, 4, 5}
```
특정 값을 제거하고 싶을 경우에는 remove(x) 함수를 사용하면 됩니다.   
x의 위치에는 제거하고 싶은 값을 적어줍니다.

