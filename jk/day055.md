# Validator
Validator는 한마디로 "유효성 검사기"이다.  
Validator는 "유효성 검사기"란 말그대로 field에  
특정한 제약조건을 걸어두는 것이다. 예로 회원가입시 이메일과 비밀번호,  
마지막으로 전화번호를 입력할때 양식에 맞게 기입해야하는 Validator를 만들어 보았다.

validators.py
```
import re

from django.forms import ValidationError


REGEX_EMAIL        = '^[a-zA-Z0-9+-_.]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$'
REGEX_PASSWORD     = '^(?=.*[A-Za-z])(?=.*\d)(?=.*[@$!%*#?&])[A-Za-z\d@$!%*#?&]{8,}$'
REGEX_PHONE_NUMBER = '\d{3}-\d{3,4}-\d{4}'

def email_validate(email):
    if not re.match(REGEX_EMAIL, email):
                raise ValidationError("이메일 형식이 아닙니다.")

def password_validate(password):
    if not re.match(REGEX_PASSWORD, password):
                raise ValidationError("비밀번호 양식이 맞지 않습니다.")

def phone_number_validate(phone_number):
    if not re.match(REGEX_PHONE_NUMBER, phone_number):
                raise ValidationError("전회번호 양식이 맞지 않습니다.")
```
프로젝트 validators.py 라는 파일을 생성후 Validator들을 만들어 주었다.  
이메일, 비밀번호와 연락처의 정규표현식을  
각각 REGEX_EMAIL, REGEX_PASSWORD, REGEX_PHONE_NUMBER 변수에 선언해준다.

그리고 각각의 validate 함수를 선언후,  
변수에 저장해둔 정규표현식과 함수의 매개변수를  
re.match를 통해 비교해준다.   
만약 정규표현식과 맞지 않는다면 ValidationError에  
전달해줄 메시지를 통해 에러처리를 해준다.

```
views.py

import json

from django.db import IntegrityError
from django.http import JsonResponse
from django.views import View

from .models import User
from .validators import email_validate, password_validate, phone_number_validate

class SignupView(View):
    def post(self, request):
        try:
            data         = json.loads(request.body)
            email        = data["email"]
            password     = data["password"]
            phone_number = data["phone_number"]
    
            email_validate(email)
            password_validate(password)				# << validator
            phone_number_validate(phone_number)

            User.objects.create(
                name         = data["name"],
                email        = email,
                password     = password,
                phone_number = phone_number
            )
            
            return JsonResponse({"message":"SUCCESS"}, status=201)
        except KeyError:
            return JsonResponse({"message":"KEY_ERROR"}, status=400)
        except IntegrityError:
            return JsonResponse({"message":"중복된 이메일입니다."}, status=400)
```
        
이제 앱 디렉토리내 뷰파일 중간에 선언해둔 Validator 들을 사용하기만 하면된다.  
하지만 그냥 코드를 입력해도 되는데, 왜 따로 Validator들을 모듈화해서 사용할까??  
애초에 모듈은 함수나 클래스를 다양한곳에서 반복적으로 사용하기위해 만들어둔 것이다.  
우리가 이 Validator 들을 다시 쓸 일이 없다면 뷰파일에 그냥 작성해도 될 것이다.  

```
class SigninView(View):
    def post(self, request):
        try:
            data     = json.loads(request.body)
            email    = data["email"]
            password = data["password"]

            email_validate(email)			# << Validator
            password_validate(password)  
            
            user_email = User.objects.get(email = email)
            if user_email.password == password:
                return JsonResponse({"message": "success"}, status = 200)
            else:
                return JsonResponse({"message": "INVALID_USER"}, status = 401)

        except KeyError:
            return JsonResponse({"message":"KEY_ERROR"}, status=400)
        except ObjectDoesNotExist:
            return JsonResponse({"message": "INVALID_USER"}, status = 401)
            
```
회원가입 아래에 간단한 로그인기능을 하는 View 클래스를 작성하였다.  
여기서도 지정해둔 validator을 사용하면   
이메일과 패스워드가 일치하는지 확인하기전에 이메일과 비밀번호의 양식이  
맞는지 먼저 확인할 수 있게된다.