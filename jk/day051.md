# django Serializer

django를 내부의 로직에 따른 복잡한 데이터를 다른   
framework에서도 이해할 수 있도록 변환이 필요할 것이다.  
이러한 목적으로 나온 것이 Serializer이다.  
따라서 serializer는 fontend와 장고를 연결할 때 보통 처음 접하게 된다.   
serializer에 대한 개념을 찾아보면,  
직렬화라는 이야기가 많이 나오지만, 쉽게 설명하면   
frontend로 데이터를 보내기 위해 장고 내부의 복잡한 데이터들을  
json/xml 등의 형태로 데이터를 변환해준다고 생각을 하면 된다.

### 사용 시기
장고에서 model.py를 통해 데이터베이스(DB)를 구축한다.   
그리고 serializer는 DB를 json으로 바꿀 때 사용되며,  
반대로 json을 DB로 바꿀 때는 deserializer가 사용된다.  
serializer 시에는 각각의 DB의 칼럼들로 정의해 줘야 한다.

### step1 기초 흐름
DB 생성  
models.py에서 DB 설정
```
from django.db import models

# Create your models here.
class Article(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
 ```

Article이라는 모델에 columns가 title과 content가 포함되어 있다.  
그리고 article내부에 DB가 저장되어 있다고 가정하겠다.   

Serializer 생성
serialize와 deserialize를 하기 위해서는   
아래와 같은 serializer 선언이 필요하다.  
보통 serializers.py라는 파일을 만들어 아래와 같이 작성한다.
```
from rest_framework import serializers

class ArticleSerializer(serializers.Serializer):
    title = serializers.CharField()
    content = serializers.TextField()
 ```

Serializing 사용법  
위에서 만든 serializer에 모델을 넣어준다.
```
serializer = ArticleSerializer(Article)
print(serializer)
'''
{ 'title': 'hellow world', 'content': 'big world' }
'''
 ```

결괏값을 보면, 위와 같이 장고의 DB의 내용이 딕셔너리 형태로 바뀐다.  
그러나 아직 JSON형태는 아니다. 아래의 과정을 통해 JSON으로 만들어보자.

```
from rest_framework.renderers import JSONRenderer

json = JSONRenderer().render(serializer.data)
json
'''
b'{ "title": "hellow world", "content": "big world" }
'''
 ```

### Deserializing 사용법
위에서 만든 json을 장고에서 활용하기 위한 딕셔너리  
형태로 다시 바꾸는 방법은 아래와 같다.
```
import io
from rest_framework.parsers import JSONParser

stream = io.BytesIO(json)
data = JSONParser().parse(stream)

serializer = ArticleSerializer(data=data)
serializer.is_valid()
# True
serializer.validated_data
'''
{ 'title': 'hellow world', 'content': 'big world' }
'''
 ```

 

 
