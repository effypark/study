# django Serializer 2

### Serializer로 DB 생성, 수정하기
serializer는 create와 update   
메서드를 추가해서 기능 추가가 가능하다. 우선 아래의 예를 보자.
```python
from rest_framework import serializers

class ArticleSerializer(serializers.Serializer):
    title = serializers.CharField()
    content = serializers.TextField()
    def create(self, validated_data):
        return Article.objects.create(**validated_data)

    def update(self, instance, validated_data):
        instance.title = validated_data.get('title', instance.title)
        instance.content = validated_data.get('content', instance.content)
        instance.save()
        return instance
 ```

create() 메서드

> save() 메서드를 호출함으로 DB 인스턴스를 생성하고자 할 때 정의한다.

 

update() 메서드

> saver() 메서드를 호출함으로 DB 인스턴스를 수정하고자 할 때 정의한다.

정리하면, serializer.save()를 통해 호출할 때  
인스턴스의 생성이나 수정이 이루어지는데,   
어떻게 로직이 이루어지는지를 정하기 위해 create()와  
update()를 사용한다.

### .save() 사용법
위에서 모델, serializer를 다 만들어 놨다.   
serializer.save()를 사용하려면 serializer 변수 설정을 먼저 해야 한다.  
설정 방법은 2가지다.

> serializer = ArticleSerializer(data=data)

인자가 하나밖에 없기 때문에 ArticleSerializer 클래스의 create로직이 사용된다.

create 메서드에 의해 DB에 생성이 된다.

>serializer = ArticleSerializer(article, data=data)

인자가 둘이기 때문에 ArticleSerializer 클래스의 update로직이 사용된다.

article은 models.py에서 정의한 Article의 인스턴트이다.

update로직에 의해 DB 값들이 수정된다.


serializer를 만들었으니 serializer.save()를 사용해서 실행하면 된다.   
이때 아래와 같이 save에 인자를 추가해서 validated_data의  
인수로 포함시키기도 가능하다.

 
serializer.save(owner=request.user)
 
is_valid()  
위에서 is_valid()를 deserializer에서 사용을 한 적이 있다.   
deserializer을 하여 데이터에 접근하거나 DB에 저장할 때는 반드시   
is_valid()를 호출해서 확인을 해줘야 한다.  
우선 공식문서의 예를 가져와서 설명해 보겠다.
```
serializer = CommentSerializer(data={'email': 'foobar', 'content': 'baz'})
serializer.is_valid()
# False
serializer.errors
# {'email': ['Enter a valid e-mail address.'], 'created': ['This field is required.']}
 ```

CommentSerializer에 데이터를 넣어서 serializer변수에 넣었다.  
그리고 is_valid()를 했는데 False라고 나온 것을 확인할 수 있다.   
is_valid()가 False인 경우에 error속성을 사용 가능하다.  
따라서 serializer.errors 통해 valid 검증이 False인 이유를 알 수 있다.   
검증 실패 이유는 email의 형식이 잘못되었고,  
created는 필수 필드인데 없다는 것을 알 수 있다.

 

raise_exception=True를 인자로 아래와 같이 추가하는 것도 가능하다.

 

>serializer.is_valid(raise_exception=True)

raise_exception=True을 추가하면 ,  
is_valid의 값이 False라면 400 response를 반환해준다.

 
. validate_<field_name>
아래와 같이 serializer 코드에 모델에서 지정한 title을 넣어서  
subclass로 def validate_title를 넣는 것이 가능하다.

```
from rest_framework import serializers

class BlogPostSerializer(serializers.Serializer):
    title = serializers.CharField(max_length=100)
    content = serializers.CharField()

    def validate_title(self, value):
        """
        Check that the blog post is about Django.
        """
        if 'django' not in value.lower():
            raise serializers.ValidationError("Blog post is not about Django")
        return value
 ```

장고 froms에서는 .clean_<field_name>과 비슷한 방식으로  
유효성 검증이 필요한 부분에 대해서 넣을 수 있다.  
조건에 대한 유효성이 통과되면, value값을 그대로 return 하고 통과하지 못하면,  
serializers.ValidationError를 발생시킨다.

추가적으로 <field_name>에 required=False가 serializer로  
선언되지 않으면, validation 단계가 진행되지 않는다.
