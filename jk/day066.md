# 4. 고유(unique)하거나 인덱스된 열을 사용한 개별 객체 검색하는 경우

get()을 사용하여 개별 객체를 검색할 때 unique  
또는 db_index 열을 사용하는 데는 두 가지 이유가 있습니다.

첫 번째, 데이터베이스 인덱스로 인해 쿼리 속도가 빨라집니다.

또한 여러 객체가 조건과 일치하면 쿼리가 훨씬 느리게 실행될 수 있습니다.

열에 고유한 제한 조건이 있다면 위와 같은 현상이 일어나지 않을 것이기 때문에   
get()을 사용할 때는 unique, db_index 된 열을 사용합니다.

두 번째, 조회는 단 하나의 객체가 반환될 것이라고 보장하지 않습니다.

쿼리가 두 개 이상의 객체와 일치하면 데이터베이스에서 모든 객체를 검색하여 전송합니다.

수백 또는 수천 개의 레코드가 반환되면 이 페널티는 상당히 클 수 있습니다.

예시 Weblog 모델

 이 코드보다
> entry = Entry.objects.get(headline="News Item Title")

 이 코드가 빠릅니다

> entry = Entry.objects.get(id=10)  

위 코드보다 아래 코드가 빠른 이유는 id라는 열이  
데이터베이스에 의해 인덱스되었고, 고유하다는 것을 보장받기 때문입니다.

5. 필요한 항목은 즉시 검색하세요  

일반적으로 모든 부분을 필요로 하는 한 데이터   
집합의 여러 부분에 대해 데이터베이스를 여러 번 히트하는 것은   
하나의 쿼리에서 모두 검색하는 것보다 효율적이지 않습니다.  
이 사항은 루프에서 실행되는 쿼리가 있는 경우 특히 중요하므로  
하나만 필요할 때 많은 데이터베이스 쿼리를 수행할 수 있습니다.

QuerySet.select_related() 및 prefetch_related()를 사용하기

select_related() 및 prefetch_related()를 철저히 이해하고 사용하세요.

Manager가 사용 중이거나 사용되지 않을 떄를 숙지해야 합니다.  
view 코드 혹은 다른 레이어에서 필요에 따라 prefetch_related_objects()를  
사용합니다.

6. 필요없는 항목은 검색하지 마세요

QuerySet.values() 및 values_list()를 사용하기

dict 또는 list 값을 원할 때, ORM 모델 객체가  
필요하지 않은 경우에는 values()를 적절하게 사용하세요.  
템플릿 코드에서 모델 객체를 대체하는 데 유용할 수 있습니다.

QuerySet.defer() 및 only()를 사용하기

데이터베이스 열(column)이 필요없다는 것을 알고 있거나  
(대부분의 경우 필요하지 않을 것이다) 데이터베이스 열(column)이   
로드되지 않도록 하려면 defer()와 only()를 사용하세요.   
하지만 부적절하게 사용하는 경우 ORM이 별도의 쿼리로 가져와야   
하므로 더 나빠질 수도 있음을 알아두세요.

또한 지연된 필드(deferred fields)가 있는 모델을 생성할 때,  
Django 내부에서 발생하는 약간의 오버 헤드가 있음에 유의하세요.   
defer() 및 only() 메서드는 많은 텍스트 데이터를 로드하지 않거나  
Python으로 다시 변환하기 위해 많은 처리가 필요한 필드의 경우 가장 유용합니다.  
항상 그렇듯이 먼저 프로파일링을 한 다음 최적화하세요.

QuerySet.count() 사용하기

개수만 원하는 경우에 len(queryset)보다 적절합니다.

QuerySet.exists() 사용하기

적어도 하나의 결과가 존재하는지 알아내고 싶은 경우에 if queryset보다 적절합니다.

하지만

count() 및 exists()를 과도하게 사용하지 마세요  
QuerySet에서 다른 데이터가 필요하다면 그냥 계산하세요.  

예를 들어, User 모델과 many-to-many 관계가 있고, body 속성을 가진  
Email 모델이 있다고 가정하면 다음 템플릿 코드가 최적입니다.
```
{% if display_inbox %}
  {% with emails=user.emails.all %}
    {% if emails %}
      <p>You have {{ emails|length }} email(s)</p>
      {% for email in emails %}
        <p>{{ email.body }}</p>
      {% endfor %}
    {% else %}
      <p>No messages today.</p>
    {% endif %}
  {% endwith %}
{% endif %}
```
다음과 같은 이유로 최적입니다:

display_inbox가 False일 경우 데이터베이스 쿼리가   
발생하지 않아서 QuerySet이 게으르기(lazy) 때문입니다.  
with를 사용하면 나중에 사용할 수 있도록 user.emails.all을  
변수에 저장하여 다시 사용할 수 있습니다.

{% if emails %} 행은 QuerySet.__bool__()이 호출되도록 합니다.  
이 경우 user.emails.all() 쿼리가 데이터베이스에서 실행되고   
최소한 첫 번째 행은 ORM 객체로 변환됩니다.  
결과가 없으면 False를 반환하고 그렇지 않으면 True를 반환합니다.  
{{ emails|length }}를 사용하면 QuerySet.__len__()을 호출하여  
다른 쿼리를 수행하지 않고 나머지 캐시를 채웁니다.  
for 루프는 이미 채워진 캐시를 반복합니다.  
전체적으로 이 코드는 하나 또는 0개의 데이터베이스 쿼리를 수행합니다.  
수행된 유일한 의도적 최적화는 with 태그의 사용입니다.  
언제든지 QuerySet.exists() 또는 QuerySet.count()를 사용하면  
추가 쿼리가 발생합니다.

