# Dajngo ORM의 JOIN
select_related()와 prefetch_related()에 대해  
Django에서는 JOIN을 할 때, "select_related()"나  
"prefetch_related()"를 사용

selected_related는 JOIN문을 만들어 SELECT문에  
관련된 객체의 필드를 포함하여 작동한다.  
그러므로, selected_related은 1개의 데이터 베이스 쿼리에   
관련 객체를 취득하는 것이 가능하다.  
그러나 관계에서 다(多)가 되는 곳을 JOIN하여  
대규모 결과 세트를 얻어 버리는 것을 피하기 위해  
selected_related는foreign key나 one-to-one과 같은  
"대1"이되는 관계에서만 JOIN한다.

 한편. prefetch_related 는 각각의 관계에 대해  
 별도의 따로 따로 참고하여 Python 코드에 JOIN(상당의 처리)을 실시한다.  
 이것에 의해 select_related에 의해 취득할 수 있는  
 foregin key나 one-to-one 관계의 객체뿐만 아니라,  
 select_related에서는 취득 불가능했던  
 many-to-many나 one-to-many관계의 객체를 JOIN하여 다룰 수 있다. 

 각각의 사용법을 표로 나타내자면 아래와 같다.

one to one -> select_related()  
many to one	-> select_related()
one to many ->	prefetch_related()
many to many ->	prefetch_related()  

 구체적으로 아래와 같이 되어 있다고 할 수 있다.

select_relate() ; SQL쪽에서 관계를 이을 수 있는 JOIN이 된다. 1개의 SQL이 된다.

prefetch_relate() ; python쪽에서 관계를 잇는다. 내부적으로 각 객체의 pk(대체로 id)를   
IN에 전달하여 범위를 축소한다. 내부에서 cache된 것이 있다면 사용할 수 있다.

즉 자기자신으로부터 시작하여 JOIN을 쓸 수 있는 것은 selected_related()를   
사용하면 좋고, 불가능하다면 prefetch_related()를 사용하는 편이 좋다.  
여기서 "자기자신으로 부터" 라는 것이 익숙하지 않아 고생을 했다. 

간략한 분별법  
 어떤 모델끼리 관계가 복잡하다면 먼저 one to many 인지 many to one인지  
확인하는 것이 좋다.   
아래에 다양한 모델이 있는데 User과 UserKarma가 1:1관계 User과  
Comment가 1:N의 관계로 되어있다.
```
class User(models.Model):
    name = models.CharField(max_length=32, default="foo", blank=False)

class UserKarma(models.Model):
    user = models.OneToOneField(User, related_name="karma")
    point = models.IntegerField(null=False, default=0)

class Comment(models.Model):
    user = models.ForeignKey(User, related_name="comments")
    content = models.CharField(max_length=140, null=False, default="")
 Comment의 모델에 ForeignKey()의 지정이 있으므로, 이 클래스가 query의 기점이 되었을 때는 many to one로 하고 싶다.
```
 여기에 각각의 select_related()를 하였을 때의 관계는 아래와 같다.

관계	자기자신	join대상	query  
one to one' |	User |	UserKarma |	LEFT OUTER JOIN  
one' to one |	User |	User      |	 INNER JOIN  
many to one |	Comment | 	User    |	INNER JOIN  
one to many |	User	| Comment	| x  
 플랫한 레코가 리턴된다는 것을 전제로하는 듯하므로 one to many는 무리이다.  
DB에 정의로서는 1:1의 관계와 1:N의 관계 등을 신경쓰지 않으므로   
one to one'의 부분도 마찬가지이다.  
User에 데이터가 있지만 UserKarma에는 데이터가 없는 없는 경우가   
있을 수 있기 때문에 User를 키로 가정하고 LEFT OUTER JOIN으로 된다. 

 many to many관계에 대해서는 여기서 다루지 않는다.  
 아무튼 select_related()로는 JOIN하기에 무리인 경우는  
 prefetch_related()의 사용을 고려해보는 것이 좋다.

