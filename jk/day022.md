# clean architecture 2

## SOLID 상세

### SRP

단일책임 원칙  

SRP의는 '단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다'  
라고 이야기 한다. 소프트웨어 시스템은 사용자와 이해관계자를 만족시키기  
위해 변경된다. 이건 이렇게 바꿔 말할 수 있다.   
'하나의 모듈은 하나의, 오직 하나의 사용자 또는 이해관계자에 대해서만  
책임져야 한다'  
하지만 사용자나 이해관계자가 복수일 수도 있다. 이런 의미보단 해당  
변경을 요청하는 한 명 이상의 사람들을 액터라고 부르고 다시 정의하면  
'하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.'  
모듈의 정의는 응집된 소스 집합이다. 

징후 1: 우발적 중복
SRP를 위반하는 클래스의 사례로 다음과 같이 서로 매우 다른 세 명의 액터를 책임지는 Employee 클래스를 정의해볼 수 있다.

calculatePay() 메서드 - 회계팀에서 CFO 보고를 위해 사용
reportHours() 메서드 - 인사팀에서 COO 보고를 위해 사용
save() 메서드 - DBA가 CTO 보고를 위해 사용
이 결합으로 인해 CFO 팀에서 결정한 조치는 COO 팀이 의존하는 무언가에 영향을 줄 수 있다.

만약 calculatePay()와 reportHours() 가 정규 업무 시간을 계산하는 알고리즘을 공유하며, 이 알고리즘을 regularHours()라는 메서드 하나로 공유한다면 어떻게 될까?

CFO에서 정규 업무 시간을 계산하는 방식을 수정 요청하고, 수정하는 개발자가 regularHours()가 양쪽에서 호출한다는 사실을 눈치채지 못한다면 CFO 팀에서의 수정이 COO 팀의 로직에 영향을 주게 된다.

불행히도 우리는 모두 이런 상황을 목격한 경험이 있다..
SRP는 이러한 상황을 방지하기 위해 서로 다른 액터가 의존하는 코드를 분리하라고 말한다.

징후 2: 병합
소스파일에 다양하고 많은 메서드를 포함할수록, 그리고 이 메서드가 서로 다른 액터를 책임질수록 병합이 발생할 가능성이 높다.

CTO 팀에서 데이터베이스의 Employee 테이블 스키마를 수정하는 동시에 COO 팀에서 reportHours() 메서드의 보고서 포맷을 변경하기로 결정한다면 어떻게 될까?

아마 서로 다른 팀에 속한 개발자가 각자 변경사항을 적용하고, 이 변경사항은 충돌할 것이다. 병합에는 당연히 위험이 뒤따른다.

이 문제에서 벗어나는 방법은, 앞서 말했듯이 서로 다른 액터를 뒷받침하는 코드를 분리하는 것이다.

해결책
이러한 문제들의 해결책은 다양한데, 모두가 메서드를 각기 다른 클래스로 이동시키는 방식이다.
아마도 가장 확실한 해결책은 데이터와 메서드를 분리하는 방식일 것이다.

예를 들어, 아무 메서드가 없는 EmployeeData 클래스를 만들어 세 클래스가 공유하도록 하고, 각 클래스는 자신의 메서드에 반드시 필요한 소스 코드만을 포함하며 서로의 존재를 모르도록 한다면 우연한 중복을 피할 수 있다. 하지만 이 방법은 개발자가 세가지 클래스를 인스턴스화하고 추적해야 한다.

대안으로는 파사드 패턴이 있다.
EmployeeFacade에 코드는 거의 없고, 이 클래스는 세 클래스의 객체를 생성하고 요청된 메서드를 가지는 객체로 위임하는 일을 책임진다.

가장 중요한 업무 규칙을 데이터와 가깝게 배치하는 방식을 선호한다면, 가장 중요한 메서드는 기존의 Employee 클래스에 그대로 유지하되, Employee 클래스를 덜 중요한 나머지 메서드들에 대한 파사드로 사용할 수도 있다.

결론