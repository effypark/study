# clean architecture 

## DIP

### 상위 모듈은 하위 모듈에 의존해서는 안된다.
### 추상화는 세부 사항에 의존해서는 안된다.

의존 관계를 맺을 때 변화하기 쉬운 것에 의존하기보다는, 변화하지 않는 것에 의존하라는 원칙

```
class SamsungPay {
    String payment() {
        return "samsung";
    }
}
```
```
public class PayService {
    private SamsungPay pay;

    public void setPay(final SamsungPay pay) {
        this.pay = pay;
    }

    public String payment() {
        return pay.payment();
    }
}
```
이럴 경우 다른 페이 서비스가 필요하면 메서드를 다시 만들어야 한다.

그래서

```
public interface Pay {
    String payment();
}
```
```
class SamsungPay implements Pay {
    @Override
    public String payment() {
        return "samsung";
    }
}
```
```
public class KakaoPay implements Pay {
    @Override
    public String payment() {
        return "kakao";
    }
}
```
이런식으로 작성을 한 후 

```
public class PayService {
    private Pay pay;

    public void setPay(final Pay pay) {
        this.pay = pay;
    }

    public String payment() {
        return pay.payment();
    }
}
```

payService를 이렇게 리팩토링 하면

느슨한 구조의 코드가 된다.

