# 20장 업무 규칙

앱을 업무 규칙과 플러그인으로 구분하려면 업무 규칙이 실제로  
무엇인지를 잘 이해해야 한다.
엄밀하게 말하면 업무 규칙은 사업적으로 수익을 얻거나 비용을  
줄일 수 있는 규칙 또는 절차다.
더 엄밀하게 말하면 컴퓨터상으로 구현했는지와 상관없이,  
업무 규칙은 사업적으로 수익을 얻거나 비용을 줄일 수 있어야 한다.
사람이 수동으로 직접 수행하더라도 마찬가지다.

 

이러한 규칙을 핵심 업무 규칙(Critical Business Rule)이라고 부른다.  
핵심 업무 규칙은 보통 데이터를 요구한다.  
이러한 데이터를 핵심 업무 데이터(Critical Business Data)라고 부른다.
핵심 규칙과 핵심 데이터는 본질적으로 결합되어 있기 때문에  
객체로 만들 좋은 후보가 된다.

이러한 유형의 객체를 엔티티(Entity)라고 한다.

엔티티

엔티티는 컴퓨터 시스템 내부의 객체로서, 핵심 업무 데이터를 기반으로  
동작하는 일련의 조그만 핵심 업무 규칙을 구체화한다.  
엔티티 객체는 핵심 업무 데이터를 직접 포함하거나 핵심업무 데이터에   
매우 쉽게 접근할 수 있다.

핵심 엔티티는 DB, UI, 3rd party framework 에 대한 고려사항들로 인해  
오염되어서는 안 된다.  
이 클래스는 어떤 시스템에서도 업무를 수행할 수 있으며,   
시스템의 표현 방식이나 데이터 저장 방식, 그리고 해당 시스템에서  
컴퓨터가 배치되는 방식과도 무관하다.  
엔티티는 순전히 업무에 대한 것이며, 이외의 것은 없다.

유스케이스

유스케이스는 자동화된 시스템이 사용되는 방법을 설명한다.  
사용자가 제공해야 하는 입력, 사용자에게 보여줄 출력,  
그리고 해당 출력을 생성하기 위한 처리 단계를 기술한다.  
엔티티 내의 핵심 업무 규칙과는 반대로, 유스케이스는  
앱에 특화된(app-specific) 업무 규칙을 설명한다.

유스케이스는 엔티티 내부의 핵심 업무 규칙을 어떻게,  
그리고 언제 호출할지를 명시하는 규칙을 담는다  
엔티티가 어떻게 춤을 출지를 유스케이스가 제어하는 것이다.


유스케이스는 데이터를 명시하지만, 사용자 인터페이스를 기술하지는 않는다.

유스케이스만 봐서는 앱이 웹을 통해 전달되는지, 리치 클라이언트인지,   
콘솔 기반인지, 아니면 순수한 서비스인지를 구분하기란 불가능하다.

유스케이스는 시스템이 사용자에게 어떻게 보이는지를 설명하지 않는다.
이보다는 앱에 특화된 규칙을 설명하며, 이를 통해 사용자와 엔티티 사이의  
상호작용을 규정한다.  
시스템에서 데이터가 들어오고 나가는 방식은 유스케이스와는 무관하다.

유스케이스는 객체다.

유스케이스는 앱에 특화된 업무 규칙을 구현하는 하나 이상의 함수를 제공한다.  
또한 유스케이스는 입력 데이터, 출력 데이터, 유스케이스가 상호작용하는 엔티티에 대한  
참조 데이터 등의 데이터 요소를 포함한다.

엔티티는 자신을 제어하는 유스케이스에 대해 아무것도 알지 못한다.  
이는 의존성 역전 원칙을 준수하는 의존성 방향에 대한 또 다른 예다.

엔티티가 고수준이고, 유스케이스가 저수준인 이유는...  
유스케이스는 단일 앱에 특화되어 있으며, 해당 시스템의 입력과  
출력에 보다 가깝게 위치하기 때문이다.


요청 및 응답 모델

유스케이스는 입력을 받아 출력을 생성한다.  
제대로 된 유스케이스 객체라면 데이터를 사용자나 또 다른 컴포넌트와 주고 받는  
방식에 대해서는 전혀 눈치챌 수 없어야 한다.

유스케이스는 단순한 요청 데이터 구조를 입력으로 받아들이고,  
단순한 응답 데이터 구조를 출력으로 반환한다.

요청 및 응답 모델이 독립적이지 않다면, 그 모델에 의존하는 유스케이스도  
결국 해당 모델이 수반하는 의존성에 간접적으로 결합되어 버린다.  

엔티티 객체를 가리키는 참조를 요청 및 응답 데이터 구조에 포함하려는  
유혹을 받을 수도 있다.

엔티티와 요청/응답 모델은 상당히 많은 데이터를 공유하므로  
이러한 방식이 적합해 보일 수도 있다.

하지만 이 유혹을 떨쳐내라!

이들 두 객체의 목적은 완전히 다르다.

시간이 지나면 두 객체는 완전히 다른 이유로 변경될 것이고,  
따라서 두 객체를 어떤 식으로든 함께 묶는 행위는 공통 폐쇄  
원칙과 단일 책임 원칙을 위배하게 된다.

결국 코드에는 수많은 떠돌이 데이터(tramp data)가 만들어지고,   
수많은 조건문이 추가되어 버린다.

결론
업무 규칙은 소프트웨어 시스템이 존재하는 이유다.  
업무 규칙은 핵심적인 기능이다.  
업무 규칙은 수익을 내고 비용을 줄이는 코드를 수반한다.
